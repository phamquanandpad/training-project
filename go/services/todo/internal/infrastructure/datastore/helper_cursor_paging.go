package datastore

import (
	"encoding/base64"
	"fmt"
	"strings"
	"time"

	"github.com/phamquanandpad/training-project/services/todo/internal/domain/model/todo"
)

const (
	DefaultMinDate = "1970-01-01"
	DefaultMaxDate = "9999-12-31"
)

type CursorPagingField struct {
	Column       string
	SortingOrder todo.SortingOrder
}

func BuildPageToken(values ...string) string {
	if len(values) == 0 {
		return ""
	}
	return base64.StdEncoding.EncodeToString(
		[]byte(strings.Join(values, "|")),
	)
}

func BuildPageTokenDateValue(
	date *time.Time,
	sortingOrder todo.SortingOrder,
) string {
	if date != nil {
		return date.Format("2006-01-02")
	}

	if sortingOrder == todo.SortingOrders.Asc {
		return DefaultMaxDate
	}

	return DefaultMinDate
}

func ParsePageToken(token string) []string {
	if token == "" {
		return []string{}
	}
	decodedToken, err := base64.StdEncoding.DecodeString(token)
	if err != nil {
		return []string{}
	}
	return strings.Split(string(decodedToken), "|")
}

func BuildCursorPagingCondition(fields []CursorPagingField, values []any) (string, []any) {
	nFields := len(fields)
	if nFields == 0 || nFields != len(values) {
		return "", nil
	}

	return buildFlattenedCursorPagingCondition(
		fields,
		values,
		0,
		make([]string, 0),
		make([]any, 0),
	)
}

// This function is generated by AI
func buildFlattenedCursorPagingCondition(
	fields []CursorPagingField,
	values []any,
	index int,
	prefixSQL []string,
	prefixArgs []any,
) (string, []any) {
	// Base Case: If we've processed all fields, stop.
	if index >= len(fields) {
		return "", nil
	}

	currentField := fields[index]
	currentValue := values[index]

	// 1. Determine the operator for the current column
	// DESC -> strictly smaller (<)
	// ASC  -> strictly larger (>)
	op := ">"
	if currentField.SortingOrder == todo.SortingOrders.Desc {
		op = "<"
	}

	var (
		currentClauseParts []string // nolint: prealloc
		currentClauseArgs  []any    // nolint: prealloc
	)

	// A. Add the history (Previous columns must be EQUAL)
	currentClauseParts = append(currentClauseParts, prefixSQL...)
	currentClauseArgs = append(currentClauseArgs, prefixArgs...)

	// B. Add the current column
	currentClauseParts = append(currentClauseParts, fmt.Sprintf("%s %s ?", currentField.Column, op))
	currentClauseArgs = append(currentClauseArgs, currentValue)

	// C. Combine into a single parenthesized block
	// "(col1 = ? AND col2 > ?)"
	fullCurrentClause := fmt.Sprintf("(%s)", strings.Join(currentClauseParts, " AND "))

	// 3. Prepare for the Next Level (Recursion)
	// For the next term in the OR chain, the current column must also be EQUAL.
	nextPrefixSQL := append(prefixSQL, fmt.Sprintf("%s = ?", currentField.Column))
	nextPrefixArgs := append(prefixArgs, currentValue)

	// Recurse
	nextSQL, nextArgs := buildFlattenedCursorPagingCondition(fields, values, index+1, nextPrefixSQL, nextPrefixArgs)

	// 4. Combine Current Result with Recursive Result (using OR)
	if nextSQL == "" {
		// If this is the last column, just return the current clause
		return fullCurrentClause, currentClauseArgs
	}

	// Otherwise, join with OR
	finalSQL := fmt.Sprintf("%s OR %s", fullCurrentClause, nextSQL)
	finalArgs := append(currentClauseArgs, nextArgs...)

	return finalSQL, finalArgs
}
